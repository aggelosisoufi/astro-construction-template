---
import { Image } from "astro:assets";

interface Props {
  images: { src: ImageMetadata; alt?: string }[];
  speed?: number;
  gap?: number;
  width?: number;
}

const { images, speed = 20, gap = 32, width = 400 } = Astro.props;
---

<section class="carousel">
  <ul 
    id="track"
    class="track"
    style={`--scroll-speed: ${speed}s; --gap: ${gap}px; --item-width: ${width}px`}
  >
    <!-- Initial images (JS will replicate more if needed) -->
    {images.map((img) => (
      <li>
        <Image
          src={img.src}
          alt={img.alt ?? ""}
          width={width}
          height={width}
          format="webp"
          fit="cover"
          loading="lazy"
        />
      </li>
    ))}
  </ul>
</section>

<style>
  .carousel {
    display: flex;
    width: 100%;
    overflow: hidden;
    place-items: center;
  }

  .carousel:hover .track {
    animation-play-state: paused;
  }

  .track {
    display: flex;
    flex-direction: row;
    gap: var(--gap, 32px);
    animation: scroll var(--scroll-speed, 20s) linear infinite;
    width: max-content;
  }

  .track li {
    flex-shrink: 0;
    width: clamp(180px, 30vw, var(--item-width, 400px));
    list-style: none;
  }

  .track :global(img) {
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 8px;
    object-fit: cover;
  }

  @keyframes scroll {
    from { transform: translateX(0); }
    to   { transform: translateX(-50%); }
  }
</style>

<script>
  window.addEventListener("DOMContentLoaded", () => {
    const track = document.getElementById("track") as HTMLUListElement;
    if (!track) return;

    const baseItems = Array.from(track.children);
    const itemWidth = parseInt(getComputedStyle(track).getPropertyValue("--item-width")) || 400;
    const gap = parseInt(getComputedStyle(track).getPropertyValue("--gap")) || 32;

    function fillTrack() {
      track.innerHTML = ""; // clear
      const viewportWidth = window.innerWidth;
      const visibleCount = Math.ceil(viewportWidth / (itemWidth + gap));
      const repeatCount = visibleCount * 2; // enough for smooth scroll

      for (let i = 0; i < repeatCount; i++) {
        for (const node of baseItems) {
          track.appendChild(node.cloneNode(true));
        }
      }
    }

    fillTrack();
    window.addEventListener("resize", fillTrack);
  });
</script>
